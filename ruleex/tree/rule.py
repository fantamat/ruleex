from abc import ABC
import numpy as np


FLOAT_TYPES = (np.float16, np.float32, np.float64, float)
INT_TYPES = (np.int, np.int32, np.int64, int)


class Rule(ABC):
    """
    Node of the RuleTree, presents the split decision in the node.
    """
    __slots__ = ("true_branch", "false_branch", "class_set", "class_hits", "num_true", "num_false")

    def __init__(self, trueBranch=None, falseBranch=None, classSet=set()):
        """
        :param trueBranch: a pointer to next Rule
        :param falseBranch: a pointer to next Rule
        :param classSet: a set of classes that the rule describes
        """
        self.class_set = set(classSet)
        self.true_branch = trueBranch
        self.false_branch = falseBranch
        self.class_hits = None
        self.num_false = 0
        self.num_true = 0

    def get_classes(self):
        """
        :return: a set of classes that Rule consider
        """
        return self.class_set

    def eval_rule(self, x):
        """
        Evaluates the rule, i.e., returns True if the rule's condition is fulfilled
        :param x: the input value
        :return: if the rule's condition holds then True, False otherwise.
        """
        pass

    def eval_all(self, x):
        """
        Evaluates a list of samples (uses numpy to optimize the decision process)
        :param x: a list of input values
        :return: a list of boolean values
        """
        pass

    def get_next(self, x):
        """
        :param x: the input value
        :return: true_branch or false_branch base on the eval__rule(self, x) value
        """
        if self.eval_rule(x):
            return self.true_branch
        else:
            return self.false_branch

    def __str__(self):
        return self.to_string()

    def to_dict(self):
        """
        Converts the Rule into the dict
        :return: a dict
        """
        output = dict()
        for slot in self.__slots__:
            output[slot] = self.__getattribute__(slot)
        output["type"] = self.__class__
        self.__setattr__()
        return output

    @staticmethod
    def load_from_dict(d):
        """
        Creates a Rule from the dictionary generated by to_dict function
        :param d: a dictionary containing all slot of the Rule
        :return: a Rule object
        """
        output = eval(d["type"])()
        for slot in output.__slots__:
            output.__setattr__(slot, d[slot])
        return output

    def to_string(self, long=False):
        """
        Printed form of the rule
        :param long: if True then the long description of the Rule is printed
        :return: string representation of the Rule
        """
        pass

    def copy(self):
        """
        copies the rule
        :return: a new instance of the rule
        """
        pass


class LinearRule(Rule):
    """
    Representation of the rule in the form of linear equation, i.e., hyper-plane split node.
    The rule can be described as a*x > b, where a and x are vector of the same size and b is a real number
    """
    __slots__ = ("a", "b")

    def __init__(self,a, b, trueBranch=None, falseBranch=None, classSet=set() ):
        """
        :param a: a vector of linear coefficients (numpy array)
        :param b: a real number
        :param trueBranch: a pointer to next node
        :param falseBranch: a pointer to next node
        :param classSet: a set of classes that node considered
        """
        super().__init__(trueBranch,falseBranch,classSet)
        if type(a) is np.ndarray:
            self.a = a
        else:
            print("Value a of LinearRule must be of the type numpy.ndarray")
            return

        if isinstance(b, FLOAT_TYPES):
            self.b = b
        else:
            print("Value of b of LinearRule must be one of the types: {}".format(FLOAT_TYPES))

    def to_string(self, long=False):
        ad = ""
        if long and (self.num_true or self.num_false):
            ad = "\nT:{} F:{}".format(self.num_true, self.num_false)
        else:
            ad = ""
        out = ""
        for i in range(len(self.a)):
            if not self.a[i] == 0:
                out += "+" if self.a[i] > 0 else "-"
                out += " " + str(abs(self.a[i]))+"*x_"+str(i) + " "
        if out[0] == "+":
            out = out[2:]
        return out + "> " + str(self.b) + ad

    def eval_rule(self, x):
        if np.sum(np.dot(self.a, x)) > self.b:
            return True
        else:
            return False

    def eval_all(self, x):
        out = np.sum(x*self.a, axis=1) < self.b
        self.num_true = np.sum(out)
        self.num_false = len(x) - self.num_true
        return out

    def copy(self):
        output = LinearRule(self.a,self.b,classSet=self.class_set)
        if self.true_branch:
            output.true_branch = self.true_branch.copy()
        if self.false_branch:
            output.false_branch = self.false_branch.copy()
        return output


class AxisRule(Rule):
    """
    Representation of the standart decision tree node, i.e., axis parallel split node.
    The rule can be described as x(i) > b, where x(i) is the value of the input on the i-th element and b is a real number
    """
    __slots__ = ("i", "b")

    def __init__(self, i, b, trueBranch=None, falseBranch=None, classSet=set()):
        """
        :param i: an index of the element that is considered in the rule x(i) > b
        :param b: a threshold
        :param trueBranch: a pointer to the next node
        :param falseBranch: a pointer to the next node
        :param classSet: a set of classes that node considered
        """
        super().__init__(trueBranch,falseBranch,classSet)
        if isinstance(i, INT_TYPES) and i >= 0:
            self.i = i
        else:
            print("Index value of AxisRule is not nonnegative integer")
            return
        if isinstance(b, FLOAT_TYPES) or type(b) is np.float:
            self.b = b
        else:
            print("Value of b of AxisRule must be a float or numpy.float")

    def eval_rule(self, x):
        if x[self.i] > self.b:
            return True
        else:
            return False

    def eval_all(self, x):
        out = x[:, self.i] > self.b
        self.num_true = np.sum(out)
        self.num_false = len(x) - self.num_true
        return out

    def to_string(self, long=False):
        ad = ""
        if long and (self.num_true or self.num_false):
            ad = "\nT:{} F:{}".format(self.num_true, self.num_false)
        else:
            ad = ""
        return "x_{} > {}".format(self.i, self.b) + ad

    def copy(self):
        output = AxisRule(self.i,self.b,classSet=self.class_set)
        if self.true_branch:
            output.true_branch = self.true_branch.copy()
        if self.false_branch:
            output.false_branch = self.false_branch.copy()
        return output


class Leaf(Rule):
    """
    A leaf node representation of the decision tree. Do not contain any of the decision, but just set of classes that
    are considered as result of the decision tree decision.
    If contains only one element in the class set the it returns its index else all set of class_set in evaluation step
    """
    __slots__ = ("description")

    def __init__(self, classSet, description=""):
        """
        Creates a representation of the leaf node that defines a decision tree classification output
        :param classSet: a set of classes that are return in evaluation
        :param description: a string that describes the leaf node (can be used to store and print some important
            information about the leaf in particular case
        """
        super().__init__(classSet=classSet)
        self.description = description

    def eval_rule(self, x):
        return self.class_set

    def eval_all(self, x):
        cl = self.class_set
        if len(self.class_set) == 1:
            cl = list(self.class_set)[0]
        return [cl for i,_ in enumerate(x)]

    def to_string(self, long=False):
        if hasattr(self, "class_hits") and self.class_hits is not None:
            hits_str = "\n({})".format(",".join(map(str, self.class_hits)))
        else:
            hits_str = ""
        ad = ""
        if long:
            ad = "\n" + self.description + hits_str
        if len(self.class_set)==0:
            return "{}" + ad
        else:
            return str(self.class_set) + ad

    def copy(self):
        return Leaf(self.class_set,description=self.description)

